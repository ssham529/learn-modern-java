- # CHAPTER 1 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가? p37
  - ## 1.1 역사의 흐름은 무엇인가? p40
  - ## 1.2 왜 아직도 자바는 변화하는가? p48
    - ### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치 p41
    - ### 1.2.2 스트림 처리 p44
    - ### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기 p45
    - ### 1.2.4 병렬성과 공유 가변 데이터 p46
    - ### 1.2.5 자바가 진화해야 하는 이유 p47
  - ## 1.3 자바 함수 p55
    - ### 1.3.1 메서드와 람다를 일급 시민으로 p49
    - ### 1.3.2 메서드 전달에서 람다로 p54
  - ## 1.4 스트림 p60
    - ### 1.4.1 멀티스레딩은 어렵다 p57
  - ## 1.5 디폴트 메서드와 자바 모듈 p62
  - ## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어 p64
  - ## 1.7 마치며 p
- # CHAPTER 2 동작 파라미터화 코드 전달하기 p67
  - ## 2.1 변화하는 요구사항에 대응하기 p68
    - ### 2.1.1 첫 번째 시도 : 녹색 사과 필터링 p69
    - ### 2.1.2 두 번째 시도 : 색을 파라미터화 p69
    - ### 2.1.3 세 번째 시도 : 가능한 모든 속성으로 필터링 p71
  - ## 2.2 동작 파라미터화 p72
    - ### 2.2.1 네 번째 시도 : 추상적 조건으로 필터링 p73
  - ## 2.3 복잡한 과정 간소화 p77
    - ### 2.3.1 익명 클래스 p79
    - ### 2.3.2 다섯 번째 시도 : 익명 클래스 사용 p79
    - ### 2.3.3 여섯 번째 시도 : 람다 표현식 사용 p81
    - ### 2.3.4 일곱 번째 시도 : 리스트 형식으로 추상화 p82
  - ## 2.4 실전 예제 p83
    - ### 2.4.1 Comparator로 정렬하기 p83
    - ### 2.4.2 Runnable로 코드 블록 실행하기 p84
    - ### 2.4.3 GUI 이벤트 처리하기 p85
    - ### 2.4.4 GUI 이벤트 처리하기 p86
  - ## 2.5 마치며 p86
- # CHAPTER 3 람다 표현식 p87
  - ## 3.1 람다란 무엇인가? p88
  - ## 3.2 어디에, 어떻게 람다를 사용할까? p91
    - ### 3.2.1 함수형 인터페이스 p92
    - ### 3.2.2 함수 디스크립터 p94
  - ## 3.3 람다 활용 : 실행 어라운드 패턴 p97
    - ### 3.3.1 1단계 : 동작 파라미터화를 기억하라 p97
    - ### 3.3.2 2단계 : 함수형 인터페이스를 이용해서 동작 전달 p98
    - ### 3.3.3 3단계 : 동작 실행 p98
    - ### 3.3.4 4단계 : 람다 전달 p99
  - ## 3.4 함수형 인터페이스 사용 p100
    - ### 3.4.1 Predicate p101
    - ### 3.4.2 Consumer p102
    - ### 3.4.3 Function p102
  - ## 3.5 형식 검사, 형식 추론, 제약 p108
    - ### 3.5.1 형식 검사 p108
    - ### 3.5.2 같은 람다, 다른 함수형 인터페이스 p109
    - ### 3.5.3 형식 추론 p112
    - ### 3.5.4 지역 변수 사용 p112
  - ## 3.6 메서드 참조 p114
    - ### 3.6.1 요약 p115
    - ### 3.6.2 생성자 참조 p119
  - ## 3.7 람다, 메서드 참조 활용하기 p121
    - ### 3.7.1 1단계 : 코드 전달 p121
    - ### 3.7.2 2단계 : 익명 클래스 사용 p122
    - ### 3.7.3 3단계 : 람다 표현식 사용 p122
    - ### 3.7.4 4단계 : 메서드 참조 사용 p123
  - ## 3.8 람다 표현식을 조합할 수 있는 유용한 메서드 p124
    - ### 3.8.1 Comparator 조합 p124
    - ### 3.8.2 Predicate 조합 p125
    - ### 3.8.3 Function 조합 p126
  - ## 3.9 비슷한 수학적 개념 p128
    - ### 3.9.1 적분 p128
    - ### 3.9.2 자바 8 람다로 연결 p130
  - ## 3.10 마치며 p131
- # CHAPTER 4 스트림 소개 p135
  - ## 4.1 스트림이란 무엇인가? p136
  - ## 4.2 스트림 시작하기 p141
  - ## 4.3 스트림과 컬렉션 p143
    - ### 4.3.1 딱 한 번만 탐색할 수 있다. p145
    - ### 4.3.2 외부 반복과 내부 반복 p146
  - ## 4.4 스트림 연산 p150
    - ### 4.4.1 중간 연산 p150
    - ### 4.4.2 최종 연산 p151
    - ### 4.4.3 스트림 이용하기 p152
  - ## 4.5 로드맵 p153
  - ## 4.6 마치며 p153
- # CHAPTER 5 (약간 어려움) 스트림 활용 p155
  - ## 5.1 필터링 p156
    - ### 5.1.1 프레디케이트로 필터링 p156
    - ### 5.1.2 고유 요소 필터링 p157
  - ## 5.2 스트림 슬라이싱 p158
    - ### 5.2.1 프레디케이트를 이용한 슬라이싱 p158
    - ### 5.2.2 스트림 축소 p159
    - ### 5.2.3 요소 건너뛰기 p160
  - ## 5.3 매핑 p162
    - ### 5.3.1 스트림의 각 요소에 함수 적용하기 p162
    - ### 5.3.2 스트림 평면화 p163
  - ## 5.4 검색과 매칭 p167
    - ### 5.4.1 프레디케이트가 적어도 한 요소와 일치하는지 확인 p167
    - ### 5.4.2 프레디케이트가 모든 요소와 일치하는지 검사 p167
    - ### 5.4.3 요소 검색 p168
    - ### 5.4.4 첫 번째 요소 찾기 p169
  - ## 5.5 리듀싱 p170
    - ### 5.5.1 요소의 합 p170
    - ### 5.5.2 최댓값과 최솟값 p172
  - ## 5.6 실전 연습 p177
    - ### 5.6.1 거래자와 트랜잭션 p177
    - ### 5.6.2 실전 연습 정답. p179
  - ## 5.7 숫자형 스트림 p181
    - ### 5.7.1 기본형 특화 스트림 p181
    - ### 5.7.2 숫자 범위 p184
    - ### 5.7.3 숫자 스트림 활용 : 피타고라스 수 p184
  - ## 5.8 스트림 만들기 p188
    - ### 5.8.1 값으로 스트림 만들기 p188
    - ### 5.8.2 null 이 될 수 있는 객체로 스트림 만들기 p188
    - ### 5.8.3 배열로 스트림 만들기 p189
    - ### 5.8.4 파일로 스트림 만들기 p189
    - ### 5.8.5 함수로 무한 스트림 만들기 p190
  - ## 5.9 마치며 p195
- # CHAPTER 6 (어려움) 스트림으로 데이터 수집 p197
  - ## 6.1 컬렉터란 무엇인가? p199
    - ### 6.1.1 고급 리듀싱 기능을 수행하는 컬렉터 p199
    - ### 6.1.2 미리 정의된 컬렉터 p200
  - ## 6.2 리듀싱과 요약 p201
    - ### 6.2.1 스트림값에서 최댓값과 최솟값 검색 p202
    - ### 6.2.2 요약 연산 p203
    - ### 6.2.3 문자열 연결 p204
    - ### 6.2.4 범용 리듀싱 요약 연산 p205
  - ## 6.3 그룹화 p210
    - ### 6.3.1 그룹화된 요소 조작 p211
    - ### 6.3.2 다수준 그룹화 p213
    - ### 6.3.3 서브그룹으로 데이터 수집 p215
  - ## 6.4 분할 p219
    - ### 6.4.1 분할의 장점 p220
    - ### 6.4.2 숫자를 소수와 비소수로  분할하기 p222
  - ## 6.5 Collector 인터페이스 p224
    - ### 6.5.1 Collector 인터페이스의 메서드 살펴보기 p225
    - ### 6.5.2 응용하기 p230
  - ## 6.6 커스텀 컬렉터를 구현해서 성능 개선하기 p232
    - ### 6.6.1 소수로만 나누기 p232
    - ### 6.6.2 컬렉터 성능 비교 p238
  - ## 6.7 마치며 p239
- # CHAPTER 7 (어려움) 병렬 데이터 처리와 성능 p241
  - ## 7.1 병렬 스트림 p242
    - ### 7.1.1 순차 스트림을 병렬 스트림으로 변환하기 p243
    - ### 7.1.2 스트림 성능 측정 p245
    - ### 7.1.3 병렬 스트림의 올바른 사용법 p251
    - ### 7.1.4 병렬 스트림 효과적으로 사용하기 p253
  - ## 7.2 포크/조인 프레임워크 p255
    - ### 7.2.1 RecursiveTask 활용 p255
    - ### 7.2.2 포크/조인 프레임워크를 제대로 사용하는 방법 p259
    - ### 7.2.3 작업 훔치기 p261
  - ## 7.3 Spliterator 인터페이스 p262
    - ### 7.3.1 분할 과정 p263
    - ### 7.3.2 커스텀 Spliterator 구현하기 p265
  - ## 7.4 마치며 p271
- # CHAPTER 8 컬렉션 API 개선 p275
  - ## 8.1 컬렉션 팩토리 p276
    - ### 8.1.1 리스트 팩토리 p277
    - ### 8.1.2 집합 팩토리 p279
    - ### 8.1.3 맵 팩토리 p279
  - ## 8.2 리스트와 집합 처리 p280
    - ### 8.2.1 removeIf 메서드 p281
    - ### 8.2.2 replaceAll 메서드 p282
  - ## 8.3 맵 처리 p283
    - ### 8.3.1 forEach 메서드 p283
    - ### 8.3.2 정렬 메서드 p283
    - ### 8.3.3 getOrDefault 메서드 p284
    - ### 8.3.4 계산 패턴 p285
    - ### 8.3.5 삭제 패턴 p286
    - ### 8.3.6 교체 패턴 p287
    - ### 8.3.7 합침 p288
  - ## 8.4 개선된 ConcurrentHashMap p290
    - ### 8.4.1 리듀스와 검색 p290
    - ### 8.4.2 계수 p291
    - ### 8.4.3 집합뷰 p291
  - ## 8.5 마치며 p292
- # CHAPTER 9 리팩터링, 테스팅, 디버깅 p293
  - ## 9.1 가독성과 유연성을 개선하는 리팩터링 p294
    - ### 9.1.1 코드 가독성 개선 p294
    - ### 9.1.2 익명 클래스를 람다 표현식으로 리팩터링하기 p295
    - ### 9.1.3 람다 표현식을 메서드 참조로 리팩터링하기 p296
    - ### 9.1.4 명령형 데이터 처리를 스트림으로 리팩터링하기 p298
    - ### 9.1.5 코드 유연생 개선 p299
  - ## 9.2 람다로 객체지향 디자인 패턴 리팩터링하기 p301
    - ### 9.2.1 전략 p302
    - ### 9.2.2 템플릿 메서드 p304
    - ### 9.2.3 옵저버 p306
    - ### 9.2.4 의무 체인 p308
    - ### 9.2.5 팩토리 p310
  - ## 9.3 람다 테스팅 p312
    - ### 9.3.1 보이는 람다 표현식의 동작 테스팅 p313
    - ### 9.3.2 람다를 사용하는 메서드의 동작에 집중하라 p314
    - ### 9.3.3 복잡한 람다를 개별 메서드로 분할하기 p315
    - ### 9.3.4 고차원 함수 테스팅 p315
  - ## 9.4 디버깅 p316
    - ### 9.4.1 스택 트레이스 확인 p316
    - ### 9.4.2 정보 로깅 p318
  - ## 9.5 마치며 p320
- # CHAPTER 10 (매우 어려움) 람다를 이용한 도메인 전용 언어 p321
  - ## 10.1 도메인 전용 언어 p324
    - ### 10.1.1 DSL의 장점과 단점 p324
    - ### 10.1.2 JVM에서 이용할 수 있는 다른 DSL 해결책 p326
  - ## 10.2 최신 자바 API의 작은 DSL p331
    - ### 10.2.1 스트림 API는 컬렉션을 조작하는 DSL p332
    - ### 10.2.2 데이터를 수집하는 DSL인 Collectors p334
  - ## 10.3 자바로 DSL을 만드는 패턴과 기법 p336
    - ### 10.3.1 메서드 체인 p339
    - ### 10.3.2 중첩된 함수 이용 p342
    - ### 10.3.3 람다 표현식을 이용한 함수 시퀀싱 p344
    - ### 10.3.4 조합하기 p347
    - ### 10.3.5 DSL에 메서드 참조 사용하기 p350
  - ## 10.4 실생활의 자바 8 DSL p353
    - ### 10.4.1 JOOQ p354
    - ### 10.4.2 큐컴버 p355
    - ### 10.4.3 스프링 통합 p357
  - ## 10.5 마치며 p359
- # CHAPTER 11 null 대신 Optional 클래스 p363
  - ## 11.1 값이 없는 상황을 어떻게 처리할까? p364
    - ### 11.1.1 보수적인 자세로 NullPointerException 줄이기 p365
    - ### 11.1.2 null 때문에 발생하는 문제 p367
    - ### 11.1.3 다른 언어는 null 대신 무얼 사용하나? p367
  - ## 11.2 Optional 클래스 소개 p369
  - ## 11.3 Optional 적용 패턴 p371
    - ### 11.3.1 Optional 객체 만들기 p371
    - ### 11.3.2 맵으로 Optional의 값을 추출하고 변환하기 p372
    - ### 11.3.3 flatMap으로 Optional 객체 연결 p373
    - ### 11.3.4 Optional 스트림 조작 p378
    - ### 11.3.5 디폴트 액션과 Optional 언랩 p379
    - ### 11.3.6 두 Optional 합치기 p380
    - ### 11.3.7 필터로 특정값 거르기 p382
  - ## 11.4 Optional을 사용한 실용 예제 p384
    - ### 11.4.1 잠재적으로 null 이 될 수 있는 대상을 Optional로 감싸기 p384
    - ### 11.4.2 예외와 Optional 클래스 p385
    - ### 11.4.3 기본형 Optional을 사용하지 말아야 하는 이유 p385
    - ### 11.4.4 응용 p386
  - ## 11.5 마치며 p388
- # CHAPTER 12 새로운 날짜와 시간 API p389
  - ## 12.1 LocalDate, LocalTime, Instant, Duration, Period 클래스 p391
    - ### 12.1.1 LocalDate와 LocalTime 사용 p391
    - ### 12.1.2 날짜와 시간 조합 p393
    - ### 12.1.3 Instance 클래스 : 기계의 날짜와 시간 p393
    - ### 12.1.4 Duration과 Period 정의 p394
  - ## 12.2 날짜 조정, 파싱, 포매팅 p396
    - ### 12.2.1 TemporalAdjusters 사용하기 p398
    - ### 12.2.2 날짜와 시간 객체 출력과 파싱 p401
  - ## 12.3 다양한 시간대와 캘린더 활용 방법 p403
    - ### 12.3.1 시간대 사용하기 p404
    - ### 12.3.2 UTC/Greenwich 기준의 고정 오프셋 p405
    - ### 12.3.3 대안 캘린더 시스템 사용하기 p406
  - ## 12.4 마치며 p407
- # CHAPTER 13 디폴트 메서드 p409
  - ## 13.1 변화하는 API p412
    - ### 13.1.1 API 버전 1 p413
    - ### 13.1.2 API 버전 2 p414
  - ## 13.2 디폴트 메서드란 무엇인가? p416
  - ## 13.3 디폴트 메서드 활용 패턴 p419
    - ### 13.3.1 선택형 메서드 p419
    - ### 13.3.2 동작 다중 상속 p420
  - ## 13.4 해석 규칙 p424
    - ### 13.4.1 알아야 할 세 가지 해결 규칙 p425
    - ### 13.4.2 디폴트 메서드를 제공하는 서브인터페이스가 이긴다 p426
    - ### 13.4.3 충돌 그리고 명시적인 문제 해결 p428
    - ### 13.4.4 다이아몬드 문제 p430
  - ## 13.5 마치며 p432
- # CHAPTER 14 (매우 어려움, 내용부족) 자바 모듈 시스템 p433
  - ## 14.1 압력 : 소프트웨어 유추 p434
    - ### 14.1.1 관심사분리 p434
    - ### 14.1.2 정보 은닉 p435
    - ### 14.1.3 자바 소프트웨어 p435
  - ## 14.2 자바 모듈 시스템을 설계한 이유 p436
    - ### 14.2.1 모듈화의 한계 p436
    - ### 14.2.2 거대한 JDK p438
    - ### 14.2.3 OSGi와 비교 p439
  - ## 14.3 자바 모듈 : 큰 그림 p440
  - ## 14.4 자바 모듈 시스템으로 애플리케이션 개발하기 p442
    - ### 14.4.1 애플리케이션 셋업 p442
    - ### 14.4.2 세부적인 모듈화와 거친 모듈화 p443
    - ### 14.4.3 자바 모듈 시스템 기초 p444
  - ## 14.5 여러 모듈 활용하기 p445
    - ### 14.5.1 exports 구문 p446
    - ### 14.5.2 requires 구분 p447
    - ### 14.5.3 이름 정하기 p447
  - ## 14.6 컴파일과 패키징 p448
  - ## 14.7 자동 모듈 p452
  - ## 14.8 모듈 정의와 구문들 p453
    - ### 14.8.1 requires p454
    - ### 14.8.2 exports p454
    - ### 14.8.3 requires transitive p454
    - ### 14.8.4 exports to p455
    - ### 14.8.5 open과 opens p455
    - ### 14.8.6 uses와 provides p456
  - ## 14.9 더 큰 예제 그리고 더 배울 수 있는 방법 p456
  - ## 14.10 마치며 p457
- # CHAPTER 15 CompletableFuture와 리액티브 프로그래밍 컨셉의 기초 p461
  - ## 15.1 동시성을 구현하는 자바 지원의 진화 p464
    - ### 15.1.1 스레드와 높은 수준의 추상화 p465
    - ### 15.1.2 Executor와 스레드 풀 p467
    - ### 15.1.3 스레드의 다른 추상화 : 중첩되지 않은 메서드 호출 p469
    - ### 15.1.4 스레드에 무엇을 바라는가? p471
  - ## 15.2 동기 API와 비동기 API p472
    - ### 15.2.1 Future 형식 API p474
    - ### 15.2.2 리액티브 형식 API p475
    - ### 15.2.3 잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주 p476
    - ### 15.2.4 현실성 확인 p478
    - ### 15.2.5 비동기 API에서 예외는 어떻게 처리하는가? p479
  - ## 15.3 박스와 채널 모델 p480
  - ## 15.4 CompletableFuture와 콤비네이터를 이용한 동시성 p483
  - ## 15.5 발행-구독 그리고 리액티브 프로그래밍 p486
    - ### 15.5.1 두 플로를 합치는 예제 p488
    - ### 15.5.2 역압력 p493
    - ### 15.5.3 실제 역압력의 간단한 형태 p494
  - ## 15.6 리액티브 시스템 vs 리액티브 프로그래밍 p495
  - ## 15.7 마치며 p495
- # CHAPTER 16 CompletableFuture : 안정적 비동기 프로그래밍 p497
  - ## 16.1 Future의 단순 활용 p498
    - ### 16.1.1 Future 제한 p499
    - ### 16.1.2 CompletableFuture로 비동기 애플리케이션 만들기 p500
  - ## 16.2 비동기 API 구현 p501
    - ### 16.2.1 동기 메서드를 비동기 메서드로 변환 p502
    - ### 16.2.2 에러 처리 방법 p504
  - ## 16.3 비블록 코드 만들기 p507
    - ### 16.3.1 병렬  스트림으로 요청 병렬화하기 p508
    - ### 16.3.2 CompletableFuture로 비동기 호출 구현하기 p509
    - ### 16.3.3 더 확장성이 좋은 해결 방법 p511
    - ### 16.3.4 커스텀 Executor 사용하기 p513
  - ## 16.4 비동기 작업 파이프라인 만들기 p515
    - ### 16.4.1 할인 서비스 구현 p516
    - ### 16.4.2 할인 서비스 사용 p518
    - ### 16.4.3 동기 작업과 비동기 작업 조합하기 p519
    - ### 16.4.4 독립 CompletableFuture와 비독립 CompletableFuture 합치기 p522
    - ### 16.4.5 Future의 리플렉션과 CompletableFuture의 리플렉션 p524
    - ### 16.4.6 타임아웃 효과적으로 사용하기 p525
  - ## 16.5 CompletableFuture의 종료에 대응하는 방법 p526
    - ### 16.5.1 최저가격 검색 애플리케이션 리팩터링 p527
    - ### 16.5.2 응용 p529
  - ## 16.6 로드맵 p530
  - ## 16.7 마치며 p530
- # CHAPTER 17 (어려움) 리액티브 프로그래밍 p533
  - ## 17.1 리액티브 매니패스토 p534
    - ### 17.1.1 애플리케이션 수준의 리액티브 p536
    - ### 17.1.2 시스템 수준의 리액티브 p538
  - ## 17.2 리액티브 스트림과 플로 API p539
    - ### 17.2.1 Flow 클래스 소개 p540
    - ### 17.2.2 첫 번째 리액티브 애플리케이션 만들기 p544
    - ### 17.2.3 Processor로 데이터 변환하기 p549
    - ### 17.2.4 자바는 왜 플로 API 구현을 제공하지 않는가? p551
  - ## 17.3 리액티브 라이브러리 RxJava 사용하기 p552
    - ### 17.3.1 Observable 만들고 사용하기 p554
    - ### 17.3.2 Observable을 변환하고 합치기 p559
  - ## 17.4 마치며 p563
- # CHAPTER 18 함수형 관점으로 생각하기 p567
  - ## 18.1 시스템 구현과 유지보수 p568
    - ### 18.1.1 공유된 가변 데이터 p568
    - ### 18.1.2 선언형 프로그래밍 p570
    - ### 18.1.3 왜 함수형 프로그래밍인가? p571
  - ## 18.2 함수형 프로그래밍이란 무엇인가? p571
    - ### 18.2.1 함수형 자바 p573
    - ### 18.2.2 참조 투명성 p575
    - ### 18.2.3 객체지향 프로그래밍과 함수형 프로그래밍 p576
    - ### 18.2.4 함수형 실전 연습 p576
  - ## 18.3 재귀와 반복 p579
  - ## 18.4 마치며 p583
- # CHAPTER 19 (매우 어려움) 함수형 프로그래밍 기법 p585
  - ## 19.1 함수는 모든 곳에 존재한다 p585
    - ### 19.1.1 고차원 함수 p586
    - ### 19.1.2 커링 p588
  - ## 19.2 영속 자료구조 p590
    - ### 19.2.1 파괴적인 갱신과 함수형 p590
    - ### 19.2.2 트리를 사용한 다른 예제 p593
    - ### 19.2.3 함수형 접근법 사용 p594
  - ## 19.3 스트림과 게으른 평가 p596
    - ### 19.3.1 자기 정의 스트림 p596
    - ### 19.3.2 게으른 리스트 만들기 p599
  - ## 19.4 (매우 어려움) 패턴 매칭 p605
    - ### 19.4.1 방문자 디자인 패턴 p606
    - ### 19.4.2 패턴 매칭의 힘 p607
  - ## 19.5 기타 정보 p611
    - ### 19.5.1 캐싱 또는 기억화 p611
    - ### 19.5.2 '같은 객체를 반환함'은 무엇을 의미하는가? p613
    - ### 19.5.3 콤비네이터 p613
  - ## 19.6 마치며 p614
- # CHAPTER 20 OOP와 FP의 조화 : 자바와 스칼라 비교 p617
  - ## 20.1 스칼라 소개 p618
    - ### 20.1.1 Hello beer p618
    - ### 20.1.2 기본 자료구조 : 리스트, 집합, 맵, 튜플, 스트림, 옵션 p620
  - ## 20.2 함수 p627
    - ### 20.2.1 스칼라의 일급 함수 p627
    - ### 20.2.2 익명 함수와 클로저 p628
    - ### 20.2.3 커링 p630
  - ## 20.3 클래스와 트레이트 p632
    - ### 20.3.1 간결성을 제공하는 스칼라의 클래스 p632
    - ### 20.3.2 스칼라 트레이트와 자바 인터페이스 p633
  - ## 20.4 마치며 p635
- # CHAPTER 21 결론 그리고 자바의 미래 p637
  - ## 21.1 자바 8의 기능 리뷰 p637
    - ### 21.1.1 동작 파라미터화(람다와 메서드 참조) p638
    - ### 21.1.2 스트림 p639
    - ### 21.1.3 CompletableFuture 클래스 p640
    - ### 21.1.4 Optional 클래스 p640
    - ### 21.1.5 Flow API p641
    - ### 21.1.6 디폴트 메서드 p641
  - ## 21.2 자바 9 모듈 시스템 p642
  - ## 21.3 자바 10 지역 변수형 추론 p643
  - ## 21.4 자바의 미래 p645
    - ### 21.4.1 선언 사이트 변종 p645
    - ### 21.4.2 패턴 매칭 p645
    - ### 21.4.3 풍부한 형식의 제네릭 p647
    - ### 21.4.4 더 근본적인 불변성 지원 p649
    - ### 21.4.5 값 형식 p650
  - ## 21.5 더 빠르게 발전하는 자바 p654
  - ## 21.6 결론 p656
- # 22 부록 p657
  - ## 22.1 _APPENDIX A 기타 언어 업데이트 p657
    - ### 22.1.1 어노테이션
    - ### 22.1.2 일반화된 대상 형식 추론
  - ## 22.2 _APPENDIX B 기타 라이브러리 업데이트 p663
    - ### 22.2.1 컬렉션
    - ### 22.2.2 동시성
    - ### 22.2.3 Arrays
    - ### 22.2.4 Number와 Math
    - ### 22.2.5 Files
    - ### 22.2.6 리플렉션
    - ### 22.2.7 String
  - ## 22.3 _APPENDIX C 스트림에 여러 연산 병렬로 실행하기 p673
    - ### 22.3.1 스트림 포킹
    - ### 22.3.2 성능 문제
  - ## 22.4 _APPENDIX D 람다와 JVM 바이트코드 p683
    - ### 22.4.1 익명 클래스
    - ### 22.4.2 바이트코드 생성
    - ### 22.4.3 구원투수 InvokeDynamic
    - ### 22.4.4 코드 생성 전략
